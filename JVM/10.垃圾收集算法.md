---
title: 10.垃圾收集算法
tags: []
---

##### 标记-清除算法

&#8195;&#8195;首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，这种方式存在两个问题：
- 效率：标记和清除两个过程的效率都不高。
- 空间：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存。

##### 复制算法

&#8195;&#8195;将可用内存容量划分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

&#8195;&#8195;**新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的`Eden`空间和两块较小的`Survivor`空间，每次使用Eden和其中一块Survivor**。当回收时，将Eden和Survivor中一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例时8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%，10%的内存会被浪费。**当Survivor空间不够用时，需要依赖其他内存（老年代）进行分配担保（将Survivor存放不下的对象复制到老年代中）**。

&#8195;&#8195;在对象存活率较高时就要进行较多的复制操作，效率将会变低。

##### 标记-整理算法

&#8195;&#8195;“标记-整理”（Mark-Compact）算法，标记过程与“标记-清除”算法一样，但后续步骤不是对可回收对象进行清理，而是**让所有存活的对象都向一端移动，然后然后直接清理端边界外的内存**。

##### 分代收集算法

&#8195;&#8195;根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。**在新生代中每次垃圾收集时都发现有大批对象死去，只有少量存活那就选用复制算法，老年代中因为对象存活率高，没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收**。
