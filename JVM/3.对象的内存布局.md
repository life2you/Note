---
title: 3.对象的内存布局
tags: []
---

&#8195;&#8195;在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：**对象头**（Header）、**实例数据**（Instance Data）和**对齐填充**（Padding）。

- 对象头

&#8195;&#8195;HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身运行时数据，如**哈希码**（HashCode）、**GC分代年龄**、**锁状态标志**、**线程持有的锁**、**偏向线程ID**、**偏向时间戳**等，这部分数据的长度在32位和64位虚拟机中分别位32bit和64bit，官方称它为“Mark Word”。

&#8195;&#8195;对象头另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，简单说，查找对象的元数据信息并不一定要经过对象本身。**如果对象是一个Java数组，那在对象头重还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据确定Java对象的大小，但是从数据的元数据中却无法确定数组的大小**。

- 实例数据

&#8195;&#8195;实例数据部分是对象真正存储的有效信息，也就是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来，这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为`longs`/`doubels`、`ints`、`shorts`/`chars`、`bytes`/`booleans`、`oops`（Ordinary Object Pointers），从分配策略可以看出**相同宽度的字段总是被分配到一起**。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。

- 对齐填充

&#8195;&#8195;对齐填充并不是必然存在的，它仅仅起着占位符的作用。由于HotSpot VM的自动管理内存系统要求对象起始地址必须是8字节的整数倍（对象的大小必须是8字节的整数倍），而对象头部分正好是8字节的倍数（1倍或2倍），因为当对象实例数据部分没有对齐时，就需要对齐填充来补全。
