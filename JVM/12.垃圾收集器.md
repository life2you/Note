---
title: 12.垃圾收集器
tags: []
---

> 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

> 并发（Concurrent）：指用户线程与垃圾收集线程同时执行，用户程序在继续运行，而垃圾收集程序运行另一个CPU上
 
分代垃圾收集器
|新生代      | 老年代     | 
| ---- | ---- |
|   Serial   |     Serial Old  |
|   ParNew   |    Parallel Old  |
|   Parallel Scavenge   |  CMS    |
|G1|G1|


##### Serial收集器

&#8195;&#8195;Serial收集器是在JDK1.3.1之前是虚拟机新生代收集的唯一选择，这是一个单线程的收集器，但它的“单线程”并不是只会使用一个CPU或者一条收集线程去完成垃圾收集工作，重要的是在它进行垃圾收集时，必须暂停其他所有工作的线程，直到它收集工作结束。当然它也存在优点：简单而高效（与其他单线程比）。

##### ParNew收集器

&#8195;&#8195;ParNew收集器其实就是Serial收集器的多线程版本，它是许多运行在Server模式下虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因，**除了Serial收集器外，目前只有它能与CMS收集器配合工作（Concurrent Mark Sweep）**

&#8195;&#8195;在JDK1.5后使用`-XX:+UseConcMarkSweepGC`选项后的默认新生代收集，也可以使用`-XX:+UseParNewGC`选项来强制指定它。

##### Parallel Scavenge收集器

&#8195;&#8195;Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法，又是并行的多线程收集器。

&#8195;&#8195;Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用户运行用户代码的时间与CPU总消耗时间的比值，
> 吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）

虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

&#8195;&#8195;Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的`-XX:MaxGCPauseMillis`参数以及直接设置吞吐量大小的`-XX:GCTimeRatio`参数。

&#8195;&#8195;`-XX:GCTimeRatio`参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就是占总时间的5%
>  1 / (1+19) 

&#8195;&#8195;Parallel Scavenge收集器还有一个参数`-XX:+UseAdaptiveSizePolicy`，这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小(-Xmn)、Eden与Survivor区的比列（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。

##### Serial Old收集器

&#8195;&#8195;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它还有两大用途：
- 在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用。
- 再为CMS收集器的后备预案。

##### Parallel Old收集器

&#8195;&#8195;Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法，在JDK1.6中开始提供，出现的原因是因为如果新生代选择了Parallel Scavenge收集器，那么老年代除了Serial Old收集器外别无选择。

##### CMS收集器

&#8195;&#8195;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

&#8195;&#8195;CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：
- 初始标记（CMS initial mark）
- 并发标记 （CMS concurrent mark）
- 重新标记 （CMS remark）
- 并发清除 （CMS concurrent sweep）

其中初始标记，重新标记仍需要“Stop The World”。
**初始标记**：只是标记一下GC Roots能直接关联到的对象，速度很快。
**并发标记**：进行GC Roots Tracing的过程。
**重新标记**：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

&#8195;&#8195;CMS收集器主要优点在名字已经体现：**并发收集，低停顿，Sun公司的一些官方文档中也称之为并发低停顿收集器（Concurrent Low Pause Collector），但CMS也存在以下明显缺点：
- CMS收集器因为是面向并发设计会对CPU资源比较敏感。在并发阶段时，虽然不回导致用户线程停顿，但是因为会占用CPU资源，从而导致应用程序变慢，总吞吐量会降低。
- CMS收集器无法处理浮动垃圾（Floating Garbage），可能会出现“Concurrent Mode Failure”失败从而导致另一次Full GC的产生。**浮动垃圾**是由于CMS并发清理阶段用户线程还在运行，伴随程序运行自然还会有新的垃圾产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉。在JDK1.5中CMS收集当老年代使用了68%的空间就会被激活，JDK1.6中CMS收集器的启动阀值已经提升到92%，要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Model Failure”失败，这时虚拟机将启动后备预案：**临时启用Serial Old收集启动来重新进行老年代的垃圾收集**。
- CMS是一款基于“标记-清除”算法实现的收集器，那么收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来麻烦。
##### G1收集器

&#8195;&#8195;G1是一款面向服务端应用的垃圾收集器。与其他收集器相比：
- 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿的时间，部分其他收集器原本需要停顿Java线程的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
- 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配个就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、经过多次GC的旧对象以获取更好的收集效果。
- 空间整合：与CMS的“标记-清理”算法不同，G1从整体来看是基于标记“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不回产生空间碎片，收集后能提供规整的可用内存。
- 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

&#8195;&#8195;在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，他将Java堆划分多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的，它们都是一部分Region（不需要连续）的集合。

&#8195;&#8195;G1收集器之所以能建立可预测的停顿时间模型，是因为他可以有计划的避免在整个Java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（Garbage-First名称的由来）。

&#8195;&#8195;在G1收集器中，虚拟机使用` Remembered Set`来避免全堆扫描的。G1中每个Region都有一个与之相对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

&#8195;&#8195;G1收集器的运作大致分为以下几个步骤：
- 初始标记（Initial Marking）
- 并发标记 （Concurrent Marking）
- 最终标记 （Final Marking）
- 筛选回收（Live Data Counting and Evacuation）
**初始标记**：标记一下GCRoot能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建对象，这阶段需要停顿线程，但耗时很短。
**并发标记**：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可以与用户程序并发执行。
**最终标记**：修正在并发标记期间因为用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，然后需要把Remembered Set Logs的数据合并到Remembered Set中，该阶段需要停顿线程，但是可并行执行。
**筛选回收**：首先对各个Gegion的回收价格和成本进行排序，根据用户期望的GC停顿时间来指定回收计划。

##### 理解GC日志
```Java
[GC (System.gc()) [PSYoungGen: 2666K->528K(38400K)] 68202K->66072K(125952K), 0.0097382 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
[Full GC (System.gc()) [PSYoungGen: 528K->0K(38400K)] [ParOldGen: 65544K->427K(87552K)] 66072K->427K(125952K), [Metaspace: 3087K->3087K(1056768K)], 0.0118023 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 38400K, used 333K [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)
  eden space 33280K, 1% used [0x0000000795580000,0x00000007955d34a8,0x0000000797600000)
  from space 5120K, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000)
  to   space 5120K, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000)
 ParOldGen       total 87552K, used 427K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)
  object space 87552K, 0% used [0x0000000740000000,0x000000074006ac20,0x0000000745580000)
 Metaspace       used 3094K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 339K, capacity 388K, committed 512K, reserved 1048576K
```
以上详细信息在Intellij IDEA开发工具中启动配置项VM options中添加`-XX:+PrintGCDetails`可打印
GC日志开头的`GC`和`Full GC`说明了这次垃圾收集的停顿类型，不是用来区分新生代GC还是老年代GC的。如果有“Full”说明这次GC发生了“Stop The World”的，如果是调用`System.gc()`方法所触发的收集，那么将显示System.gc()

&#8195;&#8195;接下来的`PSYoungGen`、`ParOldGen` 表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，如：
`DefNew`：Serial收集器中的新生代。
`ParNew`：ParNew收集器中的新生代。
`PSYoungGen`：Parallel Scavenge收集器中的新生代。

> 2666K->528K(38400K) 含义是GC前内存区域已使用容量 -> GC后该内存区域已使用容量（该内存总容量）,

> 68202K->66072K(125952K) 表示GC前Java堆已使用容量 -> GC后Java堆已使用容量（Java堆总容量）

> 0.0011008 secs 表示该内存区域GC所占用的时间，单位秒。[Times: user=0.00 sys=0.00, real=0.00 secs] 这里面的user、sys、real与Liunx的time命令所输出的时间含义一样，分别代表了用户消耗的CPU时间，内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。
