---
title: 16.类加载的过程
tags: []
---

##### 加载

&#8195;&#8195;“加载”是“类加载”（Class Loading）过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事：
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

&#8195;&#8195;在获取二进制字节流的方式可以有很多方式，并没有指定要从哪里获取，如：
- 从ZIP包中读取，JAR、EAR、WAR格式的基础。
- 从网络中获取，这种场景最典型就时Applet。
- 运行时计算生成，就是动态代理技术，在`java.lang.reflect.Proxy`中就是用了`ProxyGenerator.generateProxyClass`来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流
- 由其他文件生成，如JSP文件生成对应的Class类。
- 从数据库中读取，这种场景相对少见鞋，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。

> 非数组类的加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成（开发人员可以通过定义自己的类加载器去控制字节流的获取方式，即重写一个类加载器的`loadClass()`方法）。

&#8195;&#8195;对于数组而言，**数组本身不通过类加载器创建，它是由Java虚拟机直接创建的**。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终要靠类加载器去创建。
数组类创建过程遵循规则：
- 如果数组的组件类型时引用类型，那就递归采用系统定义的加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的类名称空间上被标识（一个类必须与类加载器一起确定唯一性）。
- 如果数组的组件类型不是引用类型（如int[]数组），java虚拟机将会把数组标记为与引导类加载器关联。
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那么数组类的可见性将默认为`public`。

&#8195;&#8195;加载阶段完成后，**虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机自定义，然后在内存中实例化一个`java.lang.Class`类的对象（并不确定存放在java堆中，Class对象比较特殊，虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口**。

&#8195;&#8195;加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，这两个阶段的开始时间仍然保持着固定的先后顺序。

##### 验证

&#8195;&#8195;验证是连接阶段的第一步，该阶段目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。如果验证到输入的字节流不符合Class文件格式约束，虚拟机就应抛出一个`java.lang.VerifyError`异常或子异常类。

&#8195;&#8195;验证阶段大致上会完成下面4个阶段的检验动作：**文件格式验证**、**元数据验证**、**字节码验证**、**符号引用验证**。
1. 文件格式验证
- 是否以魔术`0xCAFEBABE`开头。
- 主、次版本号是否在当前虚拟机处理范围之内。
- 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。
- 指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量。
- CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。
- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
该验证阶段主要保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这个阶段的验证是基于`二进制字节流`进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法中进行存储。
2. 元数据验证

&#8195;&#8195;该验证是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点：
- 这个类是否有父类（除了`java.lang.Object`之外）。
- 这个类的父类是否继承了不允许被继承的类（被`final`修饰的类）。
- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
- 类中的字段、方法是否与父类产生矛盾（例如覆盖父类的final字段，或者出现不符合规则的方法重载）
3. 字节码验证

&#8195;&#8195;该阶段验证是最复杂的过程，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法进行校验分析，保证被校验累的方法在运行时不回作出危害虚拟机安全的事件，如：
- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似：
  - 在操作栈放置了一个int类型的数据，使用时却按long类型来加载本地变量表。
  - 保证跳转指令不会跳转到方法体以外的字节码指令上。
  - 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。

&#8195;&#8195;JDK1.6之后的Javac编译器和Java虚拟机进行了一项优化，给方法体的`Code`属性的属性表增加一项名为“StackMapTable”的属性，这项属性描述了**方法体中所有的基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查StackMaptable属性中的记录是否合法**。

> 在JDK1.6的HotSpot虚拟机提供了`-XX:-UseSplitVerifier`选项来关闭这项优化，或者使用参数`-XX:+FailOverToOldVerifier`要求在类型校验失败的时候退到旧的类型推导方式进行校验。而在JDK1.7之后，对于主版本号大于50的Class文件，使用类型检查来完成数据流分析校验则是唯一的选择，不允许再退回到类型推导的校验方式。
4. 符号引用验证

&#8195;&#8195;该阶段校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验：
- 符号引用中通过字符串描述的全限定名是否能找到对应的类。
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
- 符号引用中的类、字段、方法的访问性 （private、protected、public、default）是否可被当前类访问。
符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个`java.lang.IncompatibleClassChangeError`异常的子类,如`java.lang.IIIegalAccessError`、`java.lang.NoSuchFieldError`、`java.lang.NoSuchMethodError`等。

> 对于虚拟机的类加载机制来说，验证阶段是一个非常重要（但不是一定必要）的阶段。如果所运行的全部代码都已经被反复使用和验证过（如本地环境中），那么在可以考虑使用`-Xverify:none`参数来关闭大部分的类验证措施，来缩短虚拟机加载的时间。

##### 准备

&#8195;&#8195;准备阶段是正式为类变量分配内存并设置变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。**首先进行内存分配的变量仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中**。
假设一个类变量定义为：
```java
public static int value = 123;
```
变量value在准备阶段过后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value复制为123的putstatic指令是程序被编译后，存放于类构造器&lt;clinit&gt;()方法之中，所以value赋值为123的动作将在初始化阶段才会执行。
如果类字段的字段属性表中存在`ConstantValue`属性，那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，例：
```java
public static final int value = 123;
```
编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将Value赋值为123。

##### 解析

&#8195;&#8195;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

> 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要是使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

> 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

&#8195;&#8195;虚拟机只要求了在执行`anewarray`、`checkcast`、`getfield`、`getstatic`、`instanceof`、`invokedynamic`、`invokeinterface`、`invokerspecial`、`invokestatic`、`invokestatic`、`invokevirtual`、`ldc
`、`ldc_w`、`multianewarray`、`new`、`putfield`、`putstatic`这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。**对一个符号引用进行多次解析请求是很常见的，除了`invokedynamic`指令触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生效。因为invokedynamic指令的目的本身就是用于动态语言支持，它所对应的引用称为“动态调用点限定符（Dynamic Call Site Specifier），这里的动态指必须等到程序实际运行到这条指令的时候，解析动作才进行。反之其余可触发解析的指令都是静态的，可以是在刚刚完成加载阶段，还没开始执行代码时就进行解析”**。

&#8195;&#8195;解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的`CONSTANT_Class_info`、`CONSTANT_Fieldref_info`、`CONSTANT_Methodref_info`、`CONSTANT_InterfaceMethodref_info`、`CONSTANT_MethodType_info`、`CONSTANT_MethodHandle_info`、`CONSTANT_InvokeDynamic_info`7种常量类型。
1. 类或接口的解析
    
&#8195;&#8195;假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那么虚拟机完成整个解析需要以下3个步骤：
    1. 如果C不是一个数组类型，那么虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现任何异常，解析过程就宣告失败。
    2. 如果C是一个数组类型，数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”,接着由虚拟机生成一个代表此数组维度和元素的数组对象。
    3. 如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。
2. 字段解析

&#8195;&#8195;要解析一个未被解析过的字段符号引用，首先将会对字段表内的class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析过程出现任何异常，都会导致字段符号引用解析失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照以下步骤进行字段搜索：
    1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，结束查找。
    2. 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
    3.否则，如果C不是`java.lang.Object`的话，将会按照继承关系从下网上搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
    4. 否则查找失败，抛出`java.lang.NoSuchFieldError`异常。
    5. 如果成功返回引用，将会对这个字段进行权限校验，如果发现不具备访问权限，将抛出`java.lang.IIIegalAccessError`异常。
如果有**一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个几口中出现，那么编译可能拒绝编译**。
```java
public class FieldValidator {
    interface Interface0{
        int A = 0;
    }
    interface Interface1 extends Interface0{
        int A = 1;
    }
    interface Interface2{
        int A = 2;
    }
    static class Parent implements Interface1{
        public static int A = 3;
    }
    static class Sub extends Parent implements Interface2{
//        注释后无法编译
//        public static int A = 4;
    }
    public static void main(String[] args) {
        System.out.println(Sub.A);
    }
}
```
3. 类方法解析

&#8195;&#8195;类方法解析第一步与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，用C表这个类，虚拟机会按照如下步骤进行后续类方法搜索：
    1. 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那么直接抛出`java.lang.incompatibleClassChangeError`异常。
    2. 如果第一步通过后，在类C中查找是否具有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
    3. 否则，在类C的父类中递归查找是否有简单名和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
    4. 否则，在类C实现的接口列表及它们的父接口之中递归超着是否有简单名称和描述符都与目标想匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出`java.lang.AbstractMethodError`异常。
    5. 否则方法查找失败，抛出`java.lang.NoSuchMethodError`。
    6. 如果查找中成功返回直接引用，将会对这个方法进行访问权限验证，不能访问则抛出`java.lang.IIIegalAccessError`异常。
4. 接口方法解析

&#8195;&#8195;接口方法也需要先解析出接口方法表的class_inde项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，后续虚拟机进行以下操作：
    1. 如果在接口方法中发现class_index中的索引C是个类而不是接口，那么直接抛出`java.lang.IncompatibleClassChangeError`异常。
    2. 否则在接口C中查找是否具有简单名称和描述符都与目标相匹配的方法，如果有则直接返回这个方法的直接引用，查找结束。
    3. 否则在接口C的父接口中递归查找，直到`java.lang.Obecjt`类为止，查看是否有简单名称和描述符都与目标相匹配的方法，如果有则直接返回这个方法的引用，查找结束。
    4.否则查找失败，抛出`java.lang.NoSuchMethodError`异常。

> 由于接口中所有默认方法都是public的，所以不存在访问权限的问题：个人觉得作为抽象类和外部系统打交道，因为对外开发，所以尽量减少一些设置。

##### 初始化
    
&#8195;&#8195;类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。

&#8195;&#8195;准备阶段变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序定制的主观计划去初始化类变量和其他资源，也可以理解为：初始化阶段是执行类构造`&lt;clinit&gt;()`方法的过程。

> `&lt;clinit&gt;() 方法`是由编译器自动收集类中的**所有类变量的赋值动作*和**静态语句块（static{}块）中的语句合并并产生的。编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问**。
```java
public class LoadInit {
    private static int value  = 0;
    static {
        value = 1;
        _new = 1; // 可以赋值
        value = _new; // 该行编译错误
    }
    private static int _new =  1;
}
```
> &lt;clinit&gt;()方法与类的构造函数（或者说实例构造器&lt;init&gt;()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在虚拟机中第一个被执行的&lt;clinit&gt;()方法肯定是`java.lang.Object`。

> 由于父类的&lt;clinit&gt;()方法先执行，也就意味着**父类中定义的静态语句块要优先与子类的变量赋值操作**。

初始化顺序:
parent：父类
sub：子类
static：静态方法块
init：方法块
constructor：构造函数
`parent-static -> sub-static -> parent-init -> parent-constructor -> sub-init -> sub-constructor`

> clinit&gt;()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量复制的操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。

> 接口中不能使用静态语句块，但仍然有变量初始化的复制操作，因此接口和类一样都会生成&lt;clinit&gt;()方法。但接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化的时候也一样不会执行接口的&lt;clinit&gt;()方法。

> 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地枷锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，知道活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()中有耗时很长的操作，就可能造成多个进程阻塞。
```java
public class LoadIInit {
    private static int value  = 0;
    static {
//       value = 1;
        _new = 1; // 可以赋值
//        value = _new; // 该行编译错误
        if (true){
            while (true){
                try {
                    Thread.sleep(30000);
                    break;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("init");
        }
    }
    private static int _new =  1;
    public static void main(String[] args) {
        Runnable _run = new Runnable(){
            public void run() {
                LoadIInit a =  new LoadIInit();
            }
        };
        Thread a = new Thread(_run);
        Thread b = new Thread(_run);
        a.start();
        b.start();
    }
}
```
以上代码只会打印一次“init”。
